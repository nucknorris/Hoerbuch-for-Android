%!TEX root = ../docu.tex
\section{Entwicklung}
\subsection{Benutzeroberfläsche}
Hier fehlt etwas.
\subsection{Einstellungen}
Das Einstellungsmenü soll in jedem zustand der Applikation erreichbar sein. Der einzige Ort an dem dies möglich ist, ist das Menü. Hier ist nicht von einem implementierten Menü die reden. Dieses Menü ist in jeder Applikation erreichbar und wird durch das Betriebssystem bereitgestellt.

Druck ein Benutzer die Menü-Taste, welche sich an jedem gerät befindet, welches Android als Betriebssystem verwendet so öffnet sich eine Menü-Schnittstelle welche durch den Entwickler mit Einträgen befüllt werden kann um bestimmte Funktionen bereitzustellen. Eine typische Funktion ist die Bereitstellen der Einstellungsseite.

Die Konfiguration der Einstellungsmöglichkeiten, welche dem Nutzer zur Verfügung gestellt wird, erfolgt über eine XML Datei. In älteren API-Versionen wurde dies noch durch Klassen realisiert. Diese Klassen und Methode sind in den Version ab Android Version 4 veraltet und sollten nicht mehr verwendet werden.

Die erwähnte XMl-Datei wird nun durch bestimmte Regler und Kontrollstrukturen bestückt. Diese Strukturen werden durch IDs\footnote{Identifier} validiert. Ihre Werte können durch eine Abfrage aus der Anwendung heraus ausgelesen werden.

Sollten keine geeigneten vorgefertigte Kontrollstrukturen wie zum Beispiel Radio-Button oder Checkboxen vorhanden sein, so können eigene Strukturen eingebettet werden.

Im konterten Projekt existiert keine Struktur für das Speichern und durchsuchen eines Ordnerpfades. Dieser \textit{FilePicker} wurde daher eigens implementiert und kann aus dem Einstellungsmenü aufgerufen werden.

\begin{center}
\begin{figure}
\includegraphics[scale=0.7]{images/settings}
\caption{Klassen für die Implementierung der Einstellungen}
\label{settings}
\end{figure}
\end{center}

Wurde der gewünschte Ordner gefunden kann dieser in den Einstellungen gespeichert werden. Alle anderen Komponenten der Anwendung können nun auf diese Einstellungen zugreifen.

Dies wird über den \textit{PreferenceManager} realisiert. Er benötigt für die Abfrage des Wertes lediglich die ID der Einstellung, welche abgefragt werden soll. Zur Sicherheit wird bei der Abfrage ein Standartwert angegeben, im Falle das die Einstellung nicht gefundene oder ausgelesen werden konnte. Die einmal eingetragen Einstellungen sind jederzeit abrufbar und auch nach Beenden der Applikation immer noch vorhanden.

Die Abbildung \ref{settings} zeigt die benötigten Klassen für die Implementierung der Funktionalität der Einstellungen.

\subsection{Datenbank}
\subsubsection{Grundlagen}
Das Android eine Schnittstelle für SQlite Datenbanken anbietet, wurde schön in einem herausgestellten Kapitel \ref{Datenbankstrukturen} behandelt. Anschließend soll erläutert werden wie man diese Anbindung benutzt und wie Daten gespeichert und abgefragt werden können.

Zunächst benötigen wir eine Klasse welche die API-Klasse \textit{SQLiteOpenHelper} erweitert. Diese bildet nun die Schnittstelle unser Applikation und der Datenbank, welche wir benutzen möchten bzw. anlegen möchten.

Jede Applikation kann mehrere Datenbanken anlegen und verwenden. Um Datenbanken voneinander unterscheiden zu können, werden die einzelnen Datenbanken über Namen verifiziert und aufgerufen.

Um Android mitteilen zu können, welche Datenbank wir öffnen möchten, wird dem Betriebssystem mitgeteilt welche Applikation welche Datenbank öffnen möchte.

Das Resultat ist eine Verbindung zu einer SQlite Datenbank. Um Daten speichern zu können, benötigen wir Tabellen die wir beim erstellen der Datenbank mit anlegen lassen wollen.

Für diesen Zweck legen wir eine Methode mit den Namen \textit{onCreate} an. Diese Methode wird beim Erstellen der Datenbank ausgeführt und enthält alle SQL-Befehle zum Anlegen der von uns gewünschten Tabellen.

Sollte sich das Datenbankschema ändern kann dies über eine weiter Variable, welche wir dem Betriebssystem mitteilen realisiert werden. Eine Datenbankversion beschreibt den Stand der Datenbankstruktur. Sollte sich die Datenbankstruktur geändert haben wird die Versionsnummer erhöht und eine andere Methode wird beim anbinden zur Datenbank aufgerufen.


\begin{figure}
\begin{center}
\includegraphics[scale=0.7]{images/database}
\caption{Klassen für die Implementierung der Datenbank}
\label{database}
\end{center}
\end{figure}


Diese Methode nennt sich \textit{onUpgrade} und wird bei eben erwähnter Erhöhung der Versionsnummer automatisch ausgeführt. In dieser Methode sollten eine Datenmigration durchgeführt werden oder alle bestehenden Daten gelöscht werden und neue Tabellen angelegt werden.

Durch diesen Mechanismus ist eine Aktualität des Datenbanklayouts immer gegeben. In der Abbildung \ref{database} sind die Klassen ersichtlich, die es ermöglichen mit der Datenbank zu kommunizieren. Für die Verwendung der Daten ist es ratsam Objekte zu verwenden um abgefragte Datensätze weiter zu verwenden. Ein solches Objekt wird in Abbildung \ref{dbmodel} dargestellt.

\begin{figure}
\begin{center}
\includegraphics[scale=0.7]{images/dbmodel}
\caption{Obejkt zum transport der datensätze}
\label{dbmodel}
\end{center}
\end{figure}

\subsubsection{Abfragen}
Eine Datenbankabfrage wird über einen SQL-Befehl an die Datenbank gestellt. Mit dem Befehl \textit{SELECT} und der Angabe der Tabelle können Daten aus der Datenbank abgefragt werden. Die Abfrage wird dafür in eins Cursor-Objekt geladen und der Cursor anschließend zur Ausführung an die Datenbank gesendet.

Das Cursor-Objekt enthält anschließend alle abgefragten Daten, welche die Datenbank zum übergeben SQL-Befehl gefunden hat. Eine direkte Abfrage ist nicht möglich.

Es muss immer eine Cursor-Objekt verwendet werden. Möchte man nur bestimmte Daten oder zielgerichtet Datensätze aus der Datenbank laden, wird dem Cursor-Objekt eine Filterung mitgeteilt, welche von der Datenbank bei der Abfrage der Daten berücksichtigt wird.

Das Cursor-Objekt enthält eine liste von allen Dateneinträgen die gefunden wurde. Sind mehre Datensätze gefunden wurden, können diese durchlaufen werden und jeder Datensatz einzeilig betrachtet und verarbeitet werden.

Bei der Abfrage der einzelnen Felder des Datensatzes ist es nötig den Datentyp der einzelnen Daten zu kennen. Das Cursor-Objekt hat verschiedene Methoden um unterschiedliche Datentypen aus den Feldern zu lesen. Diese Typen können wie schon erwähnt nicht typischer abgefragt werden. So ist es möglich ein Datenfeld des Types \textit{Integer} in eine variable des Typen \textit{String} zu laden.

Der Zugriff der Datenbank kann nur schreibend oder lesend gewährt werden. Eine Kombination ist nicht möglich. Ein Zugang zur Datenbank kann entweder nur schreibend oder lesend sein.

Möchte man Schrieben und Lesen, wird dies durch einen schreibenden Zugriff und anschließen über einen lesenden Zugriff realisiert. Diese beiden Vorgänge müssen separat initiiert werden.

\subsubsection{Löschen}
Das Löschen von Daten erfolgt ebenso wie das Selektieren durch SQL-Befehle anders wie bei dem Selektieren existiert hierfür kein Cursor-Objekt. Es wird lediglich mitgeteilt welcher Datensatz in welcher Tabelle gelöscht werden soll.

\subsubsection{Ändern}
Ähnlich verhält es sich mit den Ändern von Datensätzen. Hierfür wird der Datenbank mitgeteilt welcher Datensatz geändert werden soll und welche Datenfelder mit welchem Wert gesetzt werden soll.

Die Referenzierung einzelner Datensätze erfolgt über Primärschaltregler oder andere Datenfelder, welche im SQL-Befehl angegeben werden müssen.

\subsubsection{Einfügen}
Das anlegen neuer Datensätze verläuft durch die Methode \textit{insert}. Diese Methode verlangt ein liste von Schlüssel-Wert-Paaren um einen Datensatz anlegen zu können.

Die Liste von Paaren repräsentiert den eigentlichen Datensatz. In ihr werden alle Datenfelder und die dazugehörigen Werte abgelegt. Ausgeschlossen ist der Primärschlüssel, dieser wird durch einen Trigger in der Datenbank automatisch erzeugt und beim Einfügen in die Datenbank an den Datensatz abgehangen und gespeichert. Der Methode wird nun die Liste mit den Daten übergeben und die Tabelle genannt, in der die Daten abgelegt werden soll.
